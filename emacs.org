#+TITLE: Literal Emacs Configuration
#+AUTHOR: Heikki Lehväslaiho
#+EMAIL: heikki.lehvaslaiho@gmail.com


* Emacs Configuration

  This is  [[https://github.com/heikkil/emacs-literal-config][my version]] of Joost Diepenmaat's Org-Babel and a literate
  programming style emacs configuration. I forked his original
  [[https://github.com/joodie/emacs-literal-config/][Github repository]] on 1st November 2013.

* How to use this configuration

  This section is copied directly from Joost except the section /Editing this
  document/ ([[Editing this document]]) is new.

** Obtaining the source

   You can find the latest public version of the configuration in [[https://github.com/heikkil/emacs-literal-config/][the
   Github repository]]. The meat of it (and the source of this
   document) is the ~emacs.org~ file.

** Installation

   This configuration is intended to be installable from scratch. It
   uses [[https://github.com/cask/cask][Cask]] to specify the package dependencies. [[https://github.com/rdallasgray/pallet][Pallet]] is installed
   to sync actual installed packages with the dependency spec.

** Installation procedure

  - Install GNU Emacs 24 or higher
  - Install Cask from https://github.com/cask/cask
  - Clone [[https://github.com/heikkil/emacs-literal-config][the repository]] as ~$HOME/.emacs.d~ (or symlink it to that
    directory).
  - Run ~cask install~ in ~$HOME/.emacs.d~
  - Start Emacs

** Issues installing

  - Emacs failing to load pallet can indicate that ~cask~ is
    attempting to install packages using a different Emacs version
    than the one you're starting. Check your ~$PATH~ and/or aliases.

  - Emacs should load this configuration without errors in a vanilla
    environment. Let me know it this is not the case.

  - If there are missing dependencies, they are shown in the
    =*Messages*= buffer with lines starting with "ERROR: ". Read the
    corresponding section below for instructions to install the
    dependencies.

** Upgrading emacs packages

   You should be periodically upgrading you emacs packages. Some
   packages get almost daily fixes. It should be enough to update them
   every few weeks with =M-x pallet-update=. Do restart emacs after
   the update.

** Editing this document

   You are expected to use emacs and version >8 of org-mode for
   editing. To do that effectively, you need to understand how this
   documents works.

   The text and its headers can be in any order that best helps
   understanding the structure. These elements are not read by emacs
   at all. The emacs lisp code that configures emacs is in emacs-lisp
   code blocks.

   When emacs starts, code in =$HOME/init.el= loads first the
   prerequisites and then this org document. The code in the
   configuration section (see Chapter [[Configuration file layout]]) scans
   the code blocks and extracts (tangles in literate programming talk)
   them into the =emacs.el= file and evaluates it. The order the
   blocks are written out is determined first by name and then their
   order in this document. Blocks without names are *not* tangled.

   The best way to edit existing code blocks is to open a separate
   buffer for it by placing the cursor in it and pressing C-c '.
   After editing, activate the code =M-x eval-buffer= and exit
   the buffer with C-c '.

   If you want to get a better understanding what any lisp code below
   do, view it in a lisp buffer, place the cursor at the word, and
   press =C-h f= on a function or =C-h v= on a variable.

** Installing new packages

   Every time you make major changes to this document (see [Editing
   this Document]) or upgrade your packages, you are strongly advised to
   note it down to a changelog file (see [ChangeLog mode]).

   New packages are usually installed using command =list-packages= to
   show the available ones and select the ones to include. The new
   ones are automatically added to your [[file:Cask][Cask]] file for tracking.

   Emacs module *[[https://github.com/Bruce-Connor/paradox][paradox]]* adds package ratings to the listing, new
   shortcuts, and customization to package listings. After run,
   =list-packages= is same as =paradox-list-packages=

   You can give feedback if you set up the =paradox-github-token=
   variable to your github token.

   #+NAME: environment
   #+BEGIN_SRC emacs-lisp
     (setq paradox-github-token t)
   #+END_SRC

* Graphics and looks

** Font

   Compared to Apple standard [[http://en.wikipedia.org/wiki/Monaco_(typeface)][Monaco]] that is a pretty good font,
   [[http://www.levien.com/type/myfonts/inconsolata.html][Inconsolata]] is clearly crispier even on screen ([[http://www.levien.com/type/myfonts/Inconsolata.otf][Download]]). In
   addition, it is optimised for printing, too. Where it is lacking in
   Unicode support, [[http://dejavu-fonts.org/wiki/Main_Page][DejaVu Sans Mono]] ([[http://dejavu-fonts.org/wiki/index.php?title=Download][Download]]) has it all.

   #+name: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (set-face-attribute 'default nil
                         :family "Inconsolata"
                         :height 140
                         :weight 'normal
                         :width 'normal)

     (when (functionp 'set-fontset-font)
       (set-fontset-font "fontset-default"
                         'unicode
                         (font-spec :family "DejaVu Sans Mono"
                                    :width 'normal
                                    :size 12.4
                                    :weight 'normal)))
   #+END_SRC

** Reduce clutter

   Remove the toolbar. It's ugly and I never use it. I keep the
   scroll bars on right -- horizontal space is cheep. Below, I set up
   the fringe to the left.

   #+name: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (when (window-system)
       (tool-bar-mode -1)
       (scroll-bar-mode (quote right)))
   #+END_SRC

** Symbols

   Show written out symbols as they should be. This is available only
   in emacs 24.4 and above. The replacements are looked up from
   =prettify-symbols-alist=. Currently only displays “lambda” as “λ”
   in lisp code.

   #+name: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (global-prettify-symbols-mode 1)
   #+END_SRC

** Fringe decorations

   [[http://www.emacswiki.org/emacs/TheFringe][The fringe]] is the vertical region at the right and left of the
   buffer. Emacs lets you customize it of course.

   Here I set up *git differences* and buffer boundaries in the left
   fringe.

   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (when (window-system)
       (require 'git-gutter-fringe))

     (global-git-gutter-mode +1)
     (setq-default indicate-buffer-boundaries 'left)
     (setq-default indicate-empty-lines +1)

   #+END_SRC

** Mode line

   The default emacs mode line is confusing and boring. [[ http://amitp.blogspot.com/2011/08/emacs-custom-mode-line.html][This setup]]
   makes it clear and easy to eye. A nice visual bell is an added
   bonus.  Some might argue that the amount of code used is excessive
   for such a small feature, but since I was able to copy, paste and
   modify, why not.

   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (setq-default
      mode-line-format
      '(;; Position, including warning for 80 columns
        (:propertize " %5l:" face mode-line-position-face)
        (:eval (propertize "%3c" 'face
                           (if (>= (current-column) 80)
                               'mode-line-80col-face
                             'mode-line-position-face)))
        ;; emacsclient [default -- keep?]
        mode-line-client
        " "
        ;; read-only or modified status
        (:eval
         (cond (buffer-read-only
                (propertize " RO " 'face 'mode-line-read-only-face))
               ((buffer-modified-p)
                (propertize " ** " 'face 'mode-line-modified-face))
               (t "    ")))
        " "
        ;; directory and buffer/file name
        (:propertize (:eval (shorten-directory default-directory 30))
                     face mode-line-folder-face)
        (:propertize "%b"
                     face mode-line-filename-face)
        ;; narrow [default -- keep?]
        " %n "

        ;; mode indicators:
        ;; vc, recursive edit, major mode, minor modes, process, global
        (vc-mode vc-mode)
        "  %["
        (:propertize mode-name
                     face mode-line-mode-face)
        "%] "
        (:eval (propertize (format-mode-line minor-mode-alist)
                           'face 'mode-line-minor-mode-face))
        " "
        (:propertize mode-line-process
                     face mode-line-process-face)
        (global-mode-string global-mode-string)

        ))

     ;; Helper function
     (defun shorten-directory (dir max-length)
       "Show up to `max-length' characters of a directory name `dir'."
       (let ((path (reverse (split-string (abbreviate-file-name dir) "/")))
             (output ""))
         (when (and path (equal "" (car path)))
           (setq path (cdr path)))
         (while (and path (< (length output) (- max-length 4)))
           (setq output (concat (car path) "/" output))
           (setq path (cdr path)))
         (when path
           (setq output (concat ".../" output)))
         output))

     ;; Extra mode line faces
     (make-face 'mode-line-read-only-face)
     (make-face 'mode-line-modified-face)
     (make-face 'mode-line-folder-face)
     (make-face 'mode-line-filename-face)
     (make-face 'mode-line-position-face)
     (make-face 'mode-line-mode-face)
     (make-face 'mode-line-minor-mode-face)
     (make-face 'mode-line-process-face)
     (make-face 'mode-line-80col-face)


     (set-face-attribute 'mode-line nil
                         :foreground "gray60" :background "gray20"
                         :inverse-video nil
                         :box '(:line-width 6 :color "gray20" :style nil))
     (set-face-attribute 'mode-line-inactive nil
                         :foreground "gray80" :background "gray40"
                         :inverse-video nil
                         :box '(:line-width 6 :color "gray40" :style nil))

     (set-face-attribute 'mode-line-read-only-face nil
                         :inherit 'mode-line-face
                         :foreground "#4271ae"
                         :box '(:line-width 2 :color "#4271ae"))
     (set-face-attribute 'mode-line-modified-face nil
                         :inherit 'mode-line-face
                         :foreground "#c82829"
                         :background "#ffffff"
                         :box '(:line-width 2 :color "#c82829"))
     (set-face-attribute 'mode-line-folder-face nil
                         :inherit 'mode-line-face
                         :foreground "gray60")
     (set-face-attribute 'mode-line-filename-face nil
                         :inherit 'mode-line-face
                         :foreground "#eab700"
                         :weight 'bold)
     (set-face-attribute 'mode-line-position-face nil
                         :inherit 'mode-line-face
                                             ;:family "Menlo"
                         :height 130
                         )
     (set-face-attribute 'mode-line-mode-face nil
                         :inherit 'mode-line-face
                         :foreground "gray80")
     (set-face-attribute 'mode-line-minor-mode-face nil
                         :inherit 'mode-line-mode-face
                         :foreground "gray40"
                         :height 110)
     (set-face-attribute 'mode-line-process-face nil
                         :inherit 'mode-line-face
                         :foreground "#718c00")
     (set-face-attribute 'mode-line-80col-face nil
                         :inherit 'mode-line-position-face
                         :foreground "black" :background "#eab700")


     ;; --------------------------------------------------------
     ;; Visual bell in Mac Carbon Emacs is an annoying black square
     ;; This blinks read background once in the echo area
     ;; Nice little alternative visual bell; Miles Bader <miles /at/ gnu.org>

     (defcustom echo-area-bell-string "*DING* " ;"♪"
       "Message displayed in mode-line by `echo-area-bell' function."
       :group 'user)

     (defcustom echo-area-bell-delay 0.1
       "Number of seconds `echo-area-bell' displays its message."
       :group 'user)

     ;; internal variables
     (defvar echo-area-bell-cached-string nil)
     (defvar echo-area-bell-propertized-string nil)
     (defun echo-area-bell ()
       "Briefly display a highlighted message in the echo-area.
         The string displayed is the value of `echo-area-bell-string',
         with a red background; the background highlighting extends to the
         right margin.  The string is displayed for `echo-area-bell-delay'
         seconds.
         This function is intended to be used as a value of `ring-bell-function'."
       (unless (equal echo-area-bell-string echo-area-bell-cached-string)
         (setq echo-area-bell-propertized-string
               (propertize
                (concat
                 (propertize
                  "x"
                  'display
                  `(space :align-to (- right ,(+ 2 (length echo-area-bell-string)))))
                 echo-area-bell-string)
                'face '(:background "red")))
         (setq echo-area-bell-cached-string echo-area-bell-string))
       (message echo-area-bell-propertized-string)
       (sit-for echo-area-bell-delay)
       (message ""))
     (setq ring-bell-function 'echo-area-bell)

   #+END_SRC

** Scrolling behavior

   Emacs's default scrolling behavior, like a lot of the default
   Emacs experience, is pretty idiosyncratic. The following snippet
   makes for a smoother scrolling behavior when using keyboard
   navigation.

   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (setq redisplay-dont-pause t
           scroll-margin 1
           scroll-step 1
           scroll-conservatively 10000
           scroll-preserve-screen-position 1)
   #+END_SRC

   This snippet makes mouse wheel and trackpad scrolling
   bearable. Scroll in 1-line increments the buffer under the mouse.

   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (setq mouse-wheel-follow-mouse 't)
     (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
   #+END_SRC

** Cursor

   The cursor shows the location between characters.

   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
      (modify-all-frames-parameters (list (cons 'cursor-type 'bar)))
   #+END_SRC

** Current line

   Current line is subtly highlighted in pale blue.

   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (global-hl-line-mode 1)
     (set-face-background hl-line-face "AliceBlue")
   #+END_SRC

** Global key bindings

  As far as reasonable, I try to keep my custom key bindings within
  the "official" restraints. Specifically, I want my global key
  bindings to start with =C-c [lower case letter]=. Implementation are
  in appropriate sections below.

* Start up

  Start with the scratch buffer; no start up screen. Restore previous
  window and file setup.

  #+NAME: startup
  #+BEGIN_SRC emacs-lisp
    (setq inhibit-startup-screen +1)
    (desktop-save-mode 1) ; emacs 24.4 feature
  #+END_SRC

** Identify yourself

   Many emacs modes produce output that includes user's name and email
   address. Set your full name (using plain ASCII to guard against
   conflicts with old modes).

   You can tell emacs your preferred email address by hard coding it.
   An alternative is to add it to your global shell environment (you
   are using *NIX operating system, aren't you?) where emacs will pick
   it up (from =~/.zshenv= or =~/.bash_profile=):

   #+BEGIN_SRC sh
     export EMAIL=heikki.lehvaslaiho@gmail.com"
   #+END_SRC

   #+NAME: startup
   #+BEGIN_SRC emacs-lisp
    (setq user-full-name "Heikki Lehvaslaiho")
    (setq user-mail-address "heikki.lehvaslaiho@gmail.com")
   #+END_SRC

** Options set using the customize interface

   By default, Emacs saves the options you set via the `customize-*`
   functions in the user init file, which is "~/.emacs.d/init.el" in
   this setup. I prefer to have these data in a separate file,
   =custom.el=. The file is created if it does not exist. =custom.el=
   is meant to be holding customizations only temporarily. Move them
   to this main document when you have time.

   #+name: customize-config
   #+BEGIN_SRC emacs-lisp
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
     (unless (file-exists-p custom-file)
       (write-region "" nil custom-file))
     (load custom-file)
   #+END_SRC

* Backups

  Default emacs behaviour is to clutter document directories with its
  backup files. The following creates numbered backups, limits the
  number of backups kept, and directs them all into
  =$HOME/.emacs.d/backups/= directory.

  #+NAME: startup
  #+BEGIN_SRC emacs-lisp
    (setq make-backup-files t) ;; Enable backup files
    ;; Enable versioning
    (setq version-control t)  ;; make numbered backups
    (setq backup-by-copying t)
    (setq kept-new-versions 6)
    (setq kept-old-versions 2)
    (setq delete-old-versions t)
    ;; Save all backup file in this directory.
    (setq backup-directory-alist (quote ((".*" . "~/.emacs.d/backups/"))))
  #+END_SRC

* Confirmations and quitting emacs

  Set short y/n abbreviations for all confirmations and ask for
  confirmation before quiting emacs.

  #+NAME: startup
  #+BEGIN_SRC emacs-lisp
    (fset 'yes-or-no-p 'y-or-n-p)
    (setq confirm-kill-emacs 'y-or-n-p)
  #+END_SRC

  Emacs pops up an annoying buffer when big chunks of text get
  replaced overflowing the undo buffer. Prevent that:

  #+NAME: startup
  #+BEGIN_SRC emacs-lisp
    (setq warning-suppress-types (quote ((undo discard-info))))
  #+END_SRC

* Formatting and white-space

  [[http://ergoemacs.org/emacs/emacs_encoding_decoding_faq.html][Character encoding]] in files and emacs buffers is an important topic
  for anyone dealing with anything other than plain ASCII English. The
  best approach is to assume UTF-8 and deal with anything else
  (Latin-1, UTF-16) only if absolutely have to.

  #+name: formatting
  #+BEGIN_SRC emacs-lisp
    (set-language-environment "UTF-8")
  #+END_SRC


  Tabs are automatically converted to spaces and trailing white space
  is shown. Global key =C-c n= indents and removes trailing white
  space from the buffer.

  #+name: formatting
  #+BEGIN_SRC emacs-lisp
    (setq-default indent-tabs-mode nil)

    (defun my/clean-buffer-formatting ()
      "Indent and clean up the buffer"
      (interactive)
      (indent-region (point-min) (point-max))
      (whitespace-cleanup))

    (global-set-key "\C-cn" 'my/clean-buffer-formatting)

    (defun my/general-formatting-hooks ()
      (setq show-trailing-whitespace 't))

    (dolist (mode-hook (my/normal-mode-hooks))
      (add-hook mode-hook 'my/general-formatting-hooks))
  #+END_SRC

  UNIXy text files should always end in a newline character. This
  tells emacs to take care of it so that you do not have to.

  #+name: formatting
  #+BEGIN_SRC emacs-lisp
   (setq require-final-newline t)
  #+END_SRC

  Emacs knows about text sentences and can navigate and mark them. By
  default sentences are separated by double space like in old
  typewriter text. Not any more.

  #+name: formatting
  #+BEGIN_SRC emacs-lisp
   (setq sentence-end-double-space nil)
  #+END_SRC

** Text (non-code) formatting

   For writing text, I prefer Emacs to do line wrapping for me. Also,
   superfluous white-space should be shown.

   #+name: formatting
   #+BEGIN_SRC emacs-lisp
     (defun my/text-formatting-hooks ()
       (my/turn-on 'auto-fill)) ; turn on automatic hard line wraps

     (add-hook 'text-mode-hook
               'my/text-formatting-hooks)
   #+END_SRC

   Pressing the enter key should indent, too. This is now done by
   default in emacs 24.4. by enableing =electric-indent-mode=.

   ##+name: formatting
   ##+BEGIN_SRC emacs-lisp
   #  ; (global-set-key (kbd "RET") 'newline-and-indent)
   ##+END_SRC

** Understand compressed formats

 This allows emacs to handle .gz files.

   #+name: formatting
   #+BEGIN_SRC emacs-lisp
     (setq auto-compression-mode t)
   #+END_SRC
** Auto refresh buffers

   A file changed on disk is updated automatically.

   #+name: formatting
   #+BEGIN_SRC emacs-lisp
     (setq global-auto-revert-mode 1)
   #+END_SRC

   Also, auto refresh dired files, but be quiet about it.

   #+name: formatting
   #+BEGIN_SRC emacs-lisp
     (setq global-auto-revert-non-file-buffers t)
     (setq auto-revert-verbose nil)
   #+END_SRC
* Editing

** CUA mode

  The biggest advantage modern emacs has over older ones is known as
  CUA-mode. It enables common =C-x=, =C-c=, =C-v= keyboard
  combinations in emacs buffers. It also adds an ability to do
  rectangle (column) editing. Press =C-<Return>= to enter it, use
  arrow keys to select, copy, and exit the rectangle editing mode by
  =C-c=.

  #+name: formatting
  #+BEGIN_SRC emacs-lisp
    (cua-mode t)
  #+END_SRC

** Abbreviations

  Emacs comes with =abbrev-mode= that is able to replace typed strings
  in context sensitive way. I use it to correct typos (teh -> the) and
  replace short strings with long, multiline texts in modes that
  I use frequently.

  #+name: abbreviations
  #+BEGIN_SRC emacs-lisp
    (setq default-abbrev-mode t)
    (cond ((file-exists-p "~/.emacs.d/abbrev_defs")
           (read-abbrev-file "~/.emacs.d/abbrev_defs")))

    (setq save-abbrevs t)                ; save abbrevs when files are saved
                                         ; you will be asked before saving

    (if (file-exists-p abbrev-file-name) ; reads the abbreviations file
        (quietly-read-abbrev-file))      ;  on startup if the file exists

  #+END_SRC

  A special form of abbreviation is a time stamp in a file. I do not
  want to see AM/PM time stamps.

  #+name: abbreviations
  #+BEGIN_SRC emacs-lisp
    (add-hook 'before-save-hook 'time-stamp)
    (setq display-time-24hr-format t)
  #+END_SRC


  To use it, you place a template using bracket or quotes in the first
  8 lines of a file. The time stamp will be added between the
  characters. Typically, the line can start with a comment character
  to mask it from the program processing the file.

  #+BEGIN_EXAMPLE
    Time-stamp: <>
    # Time-stamp: " "
  #+END_EXAMPLE


  This sort of metafunction does not really fix in any other category,
  so I call it an abbreviation.

  #+name: abbreviations
  #+BEGIN_SRC emacs-lisp
    (defun insert-buffer-name ()
      "Inserts file name of the buffer on the current buffer."
      (interactive)
      (insert (buffer-name))
      )
  #+END_SRC

** Spell Checking

  [[http://www.emacswiki.org/emacs/FlySpell][Flyspell]] checks words as you write against the [[http://aspell.net/][GNU aspell]]
  dictionaries.

  You might have to install aspell for your computer. For OS X, do it
  using [[http://brew.sh/][Homebrew]] =brew install aspell= .

   #+NAME: spell-checker
   #+BEGIN_SRC emacs-lisp

     ;; Set aspell as spell program
     (setq ispell-program-name "aspell")

     ;; Speed up aspell: ultra | fast | normal
     (setq ispell-extra-args '("--sug-mode=normal"))

     ;; Flyspell activation for text mode
     (add-hook 'text-mode-hook
               (lambda () (flyspell-mode 1)))

     ;; Remove Flyspell from some sub modes of text mode
     (dolist (hook '(change-log-mode-hook
                     log-edit-mode-hook))
       (add-hook hook (lambda () (flyspell-mode -1))))

   #+END_SRC

** iedit mode

   [[http://www.emacswiki.org/emacs/Iedit][Iedit]] mode is activated by placing the cursor to a word and
   pressing =C-c ;=. All occurrences of the word in the buffer are
   then selected and can be simultaneously edited.

  #+name: global-keys
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-c ;") 'iedit-mode)
  #+END_SRC

** Count words in a buffer

  #+name: text-files
  #+BEGIN_SRC emacs-lisp
    ;; word-count
    (defun word-count nil "Count words in buffer" (interactive)
      (shell-command-on-region (point-min) (point-max) "wc -w"))
  #+END_SRC

** Shortcut to select text within quotes

  #+name: text-files
  #+BEGIN_SRC emacs-lisp
    (defun select-text-in-quote ()
      "http://xahlee.org/emacs/modernization_mark-word.html"
      (interactive)
      (let (b1 b2)
        (skip-chars-backward "^<>([{â€œã€Œã€Žâ€¹Â«ï¼ˆã€ˆã€Šã€”ã€ã€–â¦—ã€˜\"")
        (setq b1 (point))
        (skip-chars-forward "^<>)]}â€ã€ã€â€ºÂ»ï¼‰ã€‰ã€‹ã€•ã€‘ã€—â¦˜ã€™\"")
        (setq b2 (point))
        (set-mark b1)))
    (global-set-key (kbd "C-'") 'select-text-in-quote)
  #+END_SRC

** Text editing done by external programs

  It has been quicker for me to write perl scripts to format text than
  any other way. These functions demonstrate how a standard command
  line programs that read from STDIN and write to STDOUT can be
  included into emacs workflow. Markdown and SmartyPants are equally
  antiquated functions.

  Programs need to be available in your shell path. I most often use
  [[http://gist.github.com/heikkil/7510734][txt2para.pl]] that serves as a good example of these programs.

  #+name: text-files
  #+BEGIN_SRC emacs-lisp

    (defun txt2xhtml ()
      "Turn consecutive non-empty lines of plain text into HTML <p> elements."
      (interactive)
      (shell-command-on-region (point)
             (mark) "txt2xhtml.pl" nil t))

    (defun txt2header ()
      "Turn consecutive non-empty lines of plain text into HTML <h2> elements."
      (interactive)
      (shell-command-on-region (point)
             (mark) "txt2header.pl" nil t))

    (defun txt2para ()
      "Turn consecutive non-empty lines of plain text into paragraphs."
      (interactive)
      (shell-command-on-region (point)
             (mark) "txt2para.pl" nil t))

    (defun do-mark-down (start end)
       "Invoke the Markdown algorithm on region."
       (interactive "r")
       (shell-command-on-region start end "Markdown.pl" t t))
     (global-set-key "\C-cm" 'do-mark-down)

    (defun do-smarty-pants (start end)
       "Invoke the SmartyPants algorithm on region."
       (interactive "r")
       (shell-command-on-region start end "SmartyPants.pl" t t))
     (global-set-key "\C-cs" 'do-smarty-pants)
  #+END_SRC

** Copy and comment a region or line

  #+name: text-files
  #+BEGIN_SRC emacs-lisp
    (defun copy-and-comment-region (beg end)
      "Insert a copy of the lines in region and comment them.
    When transient-mark-mode is enabled, if no region is active then only the
    current line is acted upon.

    If the region begins or ends in the middle of a line, that entire line is
    copied, even if the region is narrowed to the middle of a line.
    The copied lines are commented according to mode.

    Current position is preserved."
      (interactive "r")
      (let ((orig-pos (point-marker)))
        (save-restriction
          (widen)
          (when (and transient-mark-mode (not (use-region-p)))
            (setq beg (line-beginning-position)
                  end (line-beginning-position 2)))

          (goto-char beg)
          (setq beg (line-beginning-position))
          (goto-char end)
          (unless (= (point) (line-beginning-position))
            (setq end (line-beginning-position 2)))

          (goto-char beg)
          (insert-before-markers (buffer-substring-no-properties beg end))
          (comment-region beg end)
          (goto-char orig-pos))))

  #+END_SRC

** Underline current line

   From [[https://gist.github.com/n3mo/5366507]]

   #+name: text-files
   #+BEGIN_SRC emacs-lisp
     (defun underline-text (prefixArgCode)
       "Underlines the current line and moves point to the beginning
     of the line directly following the underlining. If
     `universal-argument' is called, prompts user for underline
     character, otherwise uses the = character."
       (interactive "P")
       (let ((selection (buffer-substring-no-properties
                 (line-beginning-position)
                         (line-end-position)))
             (under-char
              (if (equal prefixArgCode nil)
                  "="
                (read-key-sequence "Char?"))))
         (end-of-line)
         (newline-and-indent)
         (insert (apply 'concat (make-list (length selection) under-char)))
         (next-line 1)
         (beginning-of-line)))

     ;; I use the following binding: C-c u (think C-c "underline")
     (global-set-key (kbd "C-c u") 'underline-text)
   #+END_SRC

** Editing as root

  If you open a file that you do not have permissions to edit, you can
  call this function =edit-current-file-as-root= to invoke sudo rights
  within emacs. Kudos to [[http://wenshanren.org/?p=298][Wenshan]].

  #+name: global-navigation
  #+BEGIN_SRC emacs-lisp
    (defun edit-current-file-as-root ()
      "Edit as root the file associated with the current buffer"
       (interactive)
       (if (buffer-file-name)
           (progn
             (setq file (concat "/sudo:root@localhost:" (buffer-file-name)))
             (find-file file))
         (message "Buffer is not associated to a file.")))
   #+END_SRC

** Editing file lists with wdired
   [[http://www.masteringemacs.org/articles/2013/10/10/wdired-editable-dired-buffers/][Editable dired]] is part of standard emacs. Once you are in dired
   =C-x d=, directory editing, mode, you can press =C-x C-q= to edit
   file names like any text. The familiar =C-c C-c= commits the
   changes.
* Version control

  The only version control system worth using is git and [[http://magit.github.io/magit/magit.html][magit]] is
  the emacs interface to it. Various git files have their dedicated
  modes that are loaded by Cask: git-commit-mode, gitconfig-mode,
  git-rebase-mode, and gitignore-mode.

  From any buffer that is linked to git controlled file, you can hit
  =C-c g= to enter magit status window. Pressing =q= restores the
  previous window(s).

  #+name: version-control
  #+BEGIN_SRC emacs-lisp
    (global-set-key "\C-cg" 'magit-status)

    ;; full screen magit-status
    (defadvice magit-status (around magit-fullscreen activate)
      (window-configuration-to-register :magit-fullscreen)
      ad-do-it
      (delete-other-windows))

    (defun magit-quit-session ()
      "Restores the previous window configuration and kills the magit buffer"
      (interactive)
      (kill-buffer)
      (jump-to-register :magit-fullscreen))
  #+END_SRC

* Text files
** LaTeX

   Use AUCTex for all LaTeX.

   #+name: text-files
   #+BEGIN_SRC emacs-lisp
     (setq TeX-auto-save t)
         (setq TeX-parse-self t)
         (setq-default TeX-master nil)
         (add-hook 'LaTeX-mode-hook 'visual-line-mode)
         (add-hook 'LaTeX-mode-hook 'flyspell-mode)
         (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
         (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
         (setq reftex-plug-into-AUCTeX t)

     ;; default processing to pdflatex
     (setq TeX-PDF-mode t)

     (add-hook 'LaTeX-mode-hook 'turn-on-reftex)   ; with AUCTeX LaTeX mode
   #+END_SRC

   [[http://www.emacswiki.org/emacs/LaTeXPreviewPane][latex-preview-panel]] package enables preview within Emacs. I could
   add =(latex-preview-pane-enable)= here but it can be enabled  on
   the fly with =M-x latex-preview-pane-mode=


** Zsh and fish

   [[http://www.zsh.org/][Zsh]] is a command line shell that is a superset of Bash. Tell emacs
   that its =*.zsh= config files are shell scripts. I use the [[https://github.com/sorin-ionescu/prezto][pretzo]]
   configuration framework for it.

   [[http://fishshell.com/][Fish]], Friendly Interactive SHell, is faster and cleaner than Zsh,
   but does not have quite as many features. I use [[https://github.com/bpinto/oh-my-fish][Oh My Fish!]]
   management framework for it. We need to tell emacs that =*.fish=
   function files and =*.load= configuration files are shell scripts.

   #+name: text-files
   #+BEGIN_SRC emacs-lisp
     (setq auto-mode-alist
           (cons '("\\.zsh$" . shell-script-mode) auto-mode-alist))
     (setq auto-mode-alist
           (cons '("\\.load$" . shell-script-mode) auto-mode-alist))
     (setq auto-mode-alist
           (cons '("\\.fish$" . shell-script-mode) auto-mode-alist))
   #+END_SRC

   Indentation in the above setup was a problem, so I downloaded
   =emacs-fish.el= and copied it to =~/.emacs.d/elisp=.

   #+BEGIN_SRC sh
   cd ~/src
   git clone git@github.com:wwwjfy/emacs-fish.git
   cd emacs-fish
   cp emacs-fish/fish-mode.el ~/.emacs.d/elisp
   #+END_SRC


** NEURON

   NEURON is a high level programming language for computational
   neurologybiology. Unless you are in the field, you will not need
   these modes. If you do, download the =.el= files and add them into
   your custom elisp directory (see section [[Custom lisp package
   directory]]).

   #+name: text-files
   #+BEGIN_SRC emacs-lisp
     ;;
     ;; NEURON hoc and mod files
     ;;
     ;; see: http://www.sterratt.me.uk/progs/neuron/
     ;; wget http://www.sterratt.me.uk/sites/sterratt.me.uk/files/nrnhoc.el
     ;; wget http://www.sterratt.me.uk/sites/sterratt.me.uk/files/nmodl.el

     (autoload 'nrnhoc-mode "nrnhoc" "Enter NRNHOC mode." t)
     (setq auto-mode-alist (cons '("\\.hoc\\'" . nrnhoc-mode) auto-mode-alist))
     ;; (add-hook 'nrnhoc-mode-hook 'turn-on-font-lock)

     (autoload 'nmodl-mode "nmodl" "Enter NMODL mode." t)
     (setq auto-mode-alist (cons '("\\.mod\\'" . nmodl-mode) auto-mode-alist))

   #+END_SRC

** MarkDown

   Github and especially BitBucket use =markdown mode=, so my emacs
   knows about it. GitHub knows about =org-mode=, so it is not getting
   much use.

 #+name: text-files
  #+BEGIN_SRC emacs-lisp
    (autoload 'markdown-mode "markdown-mode.el"
       "Major mode for editing Markdown files" t)
    (setq auto-mode-alist
       (cons '("\\.md" . markdown-mode) auto-mode-alist))
  #+END_SRC

** Ledger

Ledger is a command line accounting program with strong emacs support.

The following sets some default reports and tells ledger to use ISO dates.

  #+name: text-files
  #+BEGIN_SRC emacs-lisp
    (autoload 'ledger-mode "ledger-mode.el"
      "Major mode for editing Ledger files" t)
    (setq auto-mode-alist
          (cons '("\\.led" . ledger-mode) auto-mode-alist))

    (setq ledger-reports
          (quote (("test" "ledger ")
                  ("bal" "ledger -f %(ledger-file) bal")
                  ("reg" "ledger -f %(ledger-file) reg")
                  ("payee" "ledger -f %(ledger-file) reg @%(payee)")
                  ("account" "ledger -f %(ledger-file) reg %(account)"))))
    (setq ledger-use-iso-dates t)

  #+END_SRC

* Programming
** Pair programming

   Normally, I think line numbers in code editors just take up space,
   but they can be useful when pair programming; calling out a line
   number is probably more efficient than pointing at the screen.

   I wrapped this in a global minor mode so turning that stuff on and
   off is easy.

   #+name: programming-setup
   #+BEGIN_SRC emacs-lisp
     (define-minor-mode my/pair-programming-mode
       "Toggle visualizations for pair programming.

     Interactively with no argument, this command toggles the mode.  A
     positive prefix argument enables the mode, any other prefix
     argument disables it.  From Lisp, argument omitted or nil enables
     the mode, `toggle' toggles the state."
       ;; The initial value.
       nil
       ;; The indicator for the mode line.
       " Pairing"
       ;; The minor mode bindings.
       '()
       :group 'my/pairing
       (linum-mode (if my/pair-programming-mode 1 -1)))

     (define-global-minor-mode my/global-pair-programming-mode
       my/pair-programming-mode
       (lambda () (my/pair-programming-mode 1)))

     (global-set-key "\C-cp" 'my/global-pair-programming-mode)
   #+END_SRC
** Perl

   I recently moved from [[http://perlbrew.pl/][perlbrew]] to [[https://github.com/tokuhirom/plenv][plenv]] as a system that provides
   user controlled perl environment that is separate from vendor
   perl.

   For OS X, install plenv with =brew install plenv; brew install
   perl-build= and install your favorite version of perl and put into
   =plenv-global= below.

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     (require 'plenv)
     (condition-case nil
         (plenv-global "5.18.1")
       (error (message "ERROR: unknown perl version. Is your plenv configured right?")))
   #+END_SRC

   Use the built-in =cperl-mode= instead of the default =perl-mode=

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.\\([pP][Llm]\\|al\\)\\'" . cperl-mode))
     (add-to-list 'interpreter-mode-alist '("perl" . cperl-mode))
     (add-to-list 'interpreter-mode-alist '("perl5" . cperl-mode))
     (add-to-list 'interpreter-mode-alist '("miniperl" . cperl-mode))

     (add-hook 'cperl-mode-hook 'n-cperl-mode-hook t)
     (defun n-cperl-mode-hook ()
       (setq cperl-indent-level 4
             cperl-close-paren-offset -4
             cperl-continued-statement-offset 4
             cperl-indent-parens-as-block t
             cperl-tab-always-indent t))
   #+END_SRC

   Call perltidy from emacs to indent and beautify perl code in the
   current buffer. This code calls the command line [[http://metacpan.org/author/SHANCOCK][ perltidy]]
   utility. It can be installed, with a module [[http://metacpan.org/pod/Perl::Tidy][Perl::Tidy]], from any
   CPAN archive.

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
      (defun perltidy ()
         "Run perltidy on the current region or buffer."
         (interactive)
         ; Inexplicably, save-excursion doesn't work here.
         (let ((orig-point (point)))
           (unless mark-active (mark-defun))
           (shell-command-on-region (point) (mark) "perltidy -q" nil t)
           (goto-char orig-point)))

     (global-set-key "\C-ct" 'perltidy)

   #+END_SRC

*** TODO Call =pod-mode= on POD documentation files and enable spell checking.

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     (autoload 'pod-mode "pod-mode"
       "Mode for editing POD files" t)
     (add-to-list 'auto-mode-alist '("\\.pod$" . pod-mode))
     (add-hook 'pod-mode-hook 'font-lock-mode)

     (add-hook 'pod-mode-hook '(lambda ( )
                                 (progn (font-lock-mode)   ; =syntax highlighting
                                        (auto-fill-mode 1) ; =wordwrap
                                        (flyspell-mode 1)  ; =spellchecking
                                        )))
   #+END_SRC

** Lisps

   For lisp code, I want ParEdit plus general highlighting etc.

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     (setq my/lisps
           '(emacs-lisp lisp clojure))

     (defun my/general-lisp-hooks ()
       (my/turn-on 'paredit
                   ;;'rainbow-delimiters
                   'highlight-parentheses))

     (dolist (mode (mapcar 'my/->mode-hook my/lisps))
       (add-hook mode
                 'my/general-lisp-hooks))
   #+END_SRC

   The most useful paredit key combinations use =C-<arrow>= that are
   taken by OS X to switch between desktops. Use the Cmd key (s for
   super), instead.

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     (when (eq system-type 'darwin)
       (eval-after-load 'paredit
         '(progn
            ;; C-left
            (define-key paredit-mode-map (kbd "s-<left>")
                        'paredit-forward-barf-sexp)
            ;; C-right
            (define-key paredit-mode-map (kbd "s-<right>")
                        'paredit-forward-slurp-sexp)
            ;; ESC-C-left
            (define-key paredit-mode-map (kbd "M-s-<left>")
                        'paredit-backward-slurp-sexp)
            ;; ESC-C-right
            (define-key paredit-mode-map (kbd "M-s-<right>")
                        'paredit-backward-barf-sexp)
          )))
#+END_SRC

** Clojure

   I'm using [[https://github.com/clojure-emacs/cider/commits/master][CIDER]] (formerly ~nrepl.el~) for clojure source/repl
   interaction.

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     (defun my/cider-mode-hooks ()
       "Clojure specific setup code that should only be run when we
       have a CIDER REPL connection"
       (cider-turn-on-eldoc-mode))

     (add-hook 'cider-mode-hook
               'my/cider-mode-hooks)
   #+END_SRC

   Also, I want ~clojure-test-mode~ available in source
   buffers.

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     (defun my/clojure-mode-hooks ()
       (my/turn-on 'clojure-test))

     (add-hook 'clojure-mode-hook
               'my/clojure-mode-hooks)
   #+END_SRC

   Clojure-test-mode =<C-c '>= key binding conflicts with org-tangle, so
   I bind that to another key.

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     (defun my/fix-org-tangle-clojure-test-mode-conflict ()
       (define-key clojure-test-mode-map "\C-c\"" 'clojure-test-show-result)
       (define-key clojure-test-mode-map "\C-c'" nil))

     (eval-after-load "clojure-test-mode"
       '(my/fix-org-tangle-clojure-test-mode-conflict))
   #+END_SRC

   I treat the REPL mode specially, since certain hooks that work in
   ~clojure-mode~ won't make sense or break functionality in
   ~cider-repl-mode~.

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     (defun my/cider-repl-mode-hooks ()
       (my/turn-on 'paredit
                   'rainbow-delimiters
                   'highlight-parentheses))

     (add-hook 'cider-repl-mode-hook
               'my/cider-repl-mode-hooks)

   #+END_SRC

** TODO Python

   Python has joined the other scripting languages in having a *env
   version manager. Point the emacs to current stable python 2 for
   global setting. Initial setup is [[https://github.com/ikame/.emacs.d/blob/master/setup-python.org][copied from here]] .

   First make sure you have installed your python dependencies runtime
   environment:

   #+BEGIN_SRC sh
     pip install elpy
     pip install rope
     pip install jedi
   #+END_SRC

   ##+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp

     (add-to-list 'auto-mode-alist '("/requirements\\.txt\\'" . conf-mode))

     (defun my/setup-python-mode ()
       "Custom command to setup python-mode"
       (interactive)
       (let ((max-column 99))
         (setq python-shell-interpreter "python"
               python-shell-interpreter-args "-i"
               ;;venv-location "~/.virtualenvs"
               whitespace-line-column max-column
               fill-column max-column
               flycheck-flake8-maximum-line-length max-column
               elpy-rpc-backend "jedi"
               ;;elpy-default-minor-modes '(eldoc-mode)
               ;;elpy-rpc-project-specific t)
         )
       (setq python-indent-offset 4)
       (setq jedi:complete-on-dot t)
       (flycheck-mode)
       ;;(pyenv-mode)
       ;;(add-hook 'focus-out-hook 'save-buffer)
       ;;(highlight-lines-matching-regexp "import i?pdb")
       ;;(highlight-lines-matching-regexp "i?pdb.set_trace()")
       (turn-on-fci-mode)  ; fill-column-indicator
       (elpy-enable)
       (highlight-indentation-mode)
       ;;(elpy-mode)
       ;;(elpy-clean-modeline)
     ))

     (add-hook 'python-mode-hook 'my/setup-python-mode)
     (add-hook 'python-mode-hook 'jedi:ac-setup)
     (add-hook 'python-mode-hook (lambda ()
                                  (require 'sphinx-doc)
                                  (sphinx-doc-mode t)))
    #+END_SRC

   [[https://github.com/naiquevin/sphinx-doc.el][Sphinx-doc]] adds a function inserting docstring skeleton for Python
   functions and methods. Inside a Python file move the cursor to some
   function/method definition and hit =C-c M-d=.

** C++

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     ;; Use the GDB visual debugging mode
     (setq gdb-many-windows t)
     ;; Turn Semantic on
     (semantic-mode 1)
     ;; Try to make completions when not typing
     (global-semantic-idle-completions-mode 1)
     ;; Use the Semantic speedbar additions
     (add-hook 'speedbar-load-hook (lambda () (require 'semantic/sb)))
     ;; Treat .h files as C++ files (instead of C)
     (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
     ;; Run compile when you press F5
     (global-set-key (kbd "<f5>") 'compile)
   #+END_SRC

* TODO Auto Complete

  Getting auto completion to work right tends to be a messy process of
  trial and error, though in recent years the situation has improved,
  with =auto-complete= mode being more or less the defacto standard.

  - Fuzzy matching isn't working the way I expected, though. Need to
    work on that.

  #+NAME: auto-complete
  #+BEGIN_SRC emacs-lisp
    (require 'fuzzy)
    (require 'auto-complete)
    (setq ac-auto-show-menu t
          ac-quick-help-delay 0.5
          ac-use-fuzzy t)
    (global-auto-complete-mode +1)

  #+END_SRC

* Navigation
** Local navigation in a buffer

   My fingers still know this old shortcut for jumping to a line number.

  #+name: local-navigation
  #+BEGIN_SRC emacs-lisp
    (global-set-key "\C-x\," 'goto-line)
  #+END_SRC

   I have to write this default key combination down since I can never
   remember it: kill line backward from cursor: =C-0 C-k=.

   An other nifty edit command =C-backspace= makes deleting words faster.

  #+name: local-navigation
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-<backspace>") (lambda ()
                                            (interactive)
                                            (kill-line 0)))
  #+END_SRC

   The most complex replace key combination made little bit easier to
   remember:

  #+name: local-navigation
  #+BEGIN_SRC emacs-lisp
    (defalias 'qrr 'query-replace-regexp)  ; M-C-S %
  #+END_SRC


 #+name: local-navigation
  #+BEGIN_SRC emacs-lisp
    ;; folding of code
    ;; http://emacs.wordpress.com/2007/01/16/quick-and-dirty-code-folding/
    (defun toggle-selective-display ()
      (interactive)
      (set-selective-display (if selective-display nil 1)))

    (global-set-key [f7] 'toggle-selective-display)
  #+END_SRC

   =M-j= is bound to join the next line with the current one. Copied from
   [[http://whattheemacsd.com/key-bindings.el-03.html][WhatTheEmacs!?]] The is an alternative of =M-^= or =C-q= for joining
   current line to previous one.

  #+name: local-navigation
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "M-j")
                    (lambda () (interactive) (join-line -1)))
    (global-set-key "\C-cq" 'delete-indentation)
  #+END_SRC

   When editing indented text, you seldom want to go to the first
   column of the line. Instead the following modifies =C-a= to move
   point back to indentation of beginning of line. Copied from [[ http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][EmacsRedux]].

   Move point to the first non-whitespace character on this line.  If
   point is already there, move to the beginning of the line.
   Effectively toggle between the first non-whitespace character and
   the beginning of the line.

  #+name: local-navigation
  #+BEGIN_SRC emacs-lisp
    (defun smarter-move-beginning-of-line (arg)
      "Move point back to indentation of beginning of line.

      Move point to the first non-whitespace character on this line.
      If point is already there, move to the beginning of the line.
      Effectively toggle between the first non-whitespace character and
      the beginning of the line.

      If ARG is not nil or 1, move forward ARG - 1 lines first.  If
      point reaches the beginning or end of the buffer, stop there."
      (interactive "^p")
      (setq arg (or arg 1))

      ;; Move lines first
      (when (/= arg 1)
        (let ((line-move-visual nil))
          (forward-line (1- arg))))

      (let ((orig-point (point)))
        (back-to-indentation)
        (when (= orig-point (point))
          (move-beginning-of-line 1))))

    ;; remap C-a to `smarter-move-beginning-of-line'
    (global-set-key [remap move-beginning-of-line]
                    'smarter-move-beginning-of-line)

  #+END_SRC

** Narrowing

   Narrowing is a way for emacs to hide part of the buffer so that
   only visible parts can be viewed *and edited*. This has the
   potential to be so confusing to an unsuspecting user that this
   feature is disabled by default. It has to be explicitly turned on.

   #+name: local-navigation
   #+BEGIN_SRC emacs-lisp
     (put 'narrow-to-region 'disabled nil)
   #+END_SRC

   [[http://emacs-fu.blogspot.com/2010/08/narrowing-buffer-contents.html][Emacs-Fu]] has an excellent article on narrowing. [[http://www.emacswiki.org/emacs/BasicNarrowing][EmacsWiki]] is worth
   checking for caveats. 

   | Visible | Function            | Binding |
   |---------+---------------------+---------|
   | region  | (narrow-to-region)  | C-x n n |
   | subtree | (narrow-to-subtree) | C-x n s |
   | all     | (widen)             | C-x n w |

** Local navigation between windows

   Emacs standard way of moving between windows opened in a frame is
   =C-x o=. It jumps the cursor through all windows one by one. I like
   to have a bit more control and use the built in *windmove* package.
   With it, =shift-<arrow>= moves the focus.

   The package description for windmove is good place to start
   reading about it:

   #+BEGIN_SRC emacs-lisp
     ; execute this lisp code in org mode
     ; by placing the curser after the closing parenthesis and press C-x C-e
     (describe-package 'windmove)
   #+END_SRC

   I need to tell org-mode to [[http://orgmode.org/manual/Conflicts.html][allow the windmove]] commands where it
   does not use them for its own purposes. These commands has to run
   after org-mode (configured below) has been executed.

   #+name: execute-last
   #+BEGIN_SRC emacs-lisp
     (windmove-default-keybindings)
     (setq windmove-wrap-around t)

     ;; Make windmove work in org-mode:
     (add-hook 'org-shiftup-final-hook 'windmove-up)
     (add-hook 'org-shiftleft-final-hook 'windmove-left)
     (add-hook 'org-shiftdown-final-hook 'windmove-down)
     (add-hook 'org-shiftright-final-hook 'windmove-right)
   #+END_SRC

   The *win-switch* package can override the =C-c o= command and
   allow to both change and resize windows.

   #+BEGIN_SRC emacs-lisp
     (describe-package 'win-switch)
   #+END_SRC

   The following sets up a two second time frame to use arrow keys to
   move between windows and use shift-arrow keys to resize the active
   window. The time that win-switch remains active will be reduced
   once I get used to it.

   ##+name: local-navigation
   #+BEGIN_SRC emacs-lisp
     (require 'win-switch)
     (win-switch-setup-keys-arrow-meta)
     (global-set-key "\C-xo" 'win-switch-dispatch)
     (setq win-switch-other-window-first nil)
     (setq win-switch-idle-time 0.75)
   #+END_SRC

** External navigation

   This allows you to google the selected region from local emacs buffer. Defines
   fuction =google=.

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
      (defun google ()
     "Google the selected region if any, display a query prompt otherwise."
     (interactive)
     (browse-url
      (concat
       "http://www.google.com/search?ie=utf-8&oe=utf-8&q="
       (url-hexify-string (if mark-active
                              (buffer-substring (region-beginning) (region-end))
                            (read-string "Google: "))))))
   #+END_SRC
** Global navigation

   This file org configuration file can always be accessed with =C-c e=.

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     (defun my/edit-emacs-configuration ()
       (interactive)
       (find-file "~/.emacs.d/emacs.org"))

     (global-set-key "\C-ce" 'my/edit-emacs-configuration)
   #+END_SRC

   I like emacs to remember files that I have visited. The =recentf=
   package allows you to see the list using  =C-x C-r=.

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
    (require 'recentf)
    (setq recentf-auto-cleanup 'never) ;; cleanup interfers with tramp mode
    (recentf-mode 1)
    (setq recentf-max-saved-items 200
          recentf-max-menu-items 35)
    (global-set-key "\C-x\ \C-r" 'recentf-open-files)
   #+END_SRC


   I like ~ido~ and ~smex~ for narrowing down files, commands, buffers
   etc. The ido mode can also be used to offer better interface to
   =recentf=. That is linked to =C-c r=.

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     (setq ido-enable-flex-matching t)
     (ido-mode (quote both))
     ;;(ido-yes-or-no-mode +1)
     (setq ido-everywhere t)
     ;;(global-set-key "\M-x" 'smex)

     (defun recentf-ido-find-file ()
       "Find a recent file using ido."
       (interactive)
       (let ((file (ido-completing-read "Choose recent file: " recentf-list nil t)))
         (when file
           (find-file file))))

     (global-set-key (kbd "C-c r") 'recentf-ido-find-file)
   #+END_SRC

   Tell smex that [[http://www.emacswiki.org/emacs/Smex][space inserts '-']] like we are used to when typing to
   the echo space.

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     (defadvice smex (around space-inserts-hyphen activate compile)
           (let ((ido-cannot-complete-command
                  `(lambda ()
                     (interactive)
                     (if (string= " " (this-command-keys))
                         (insert ?-)
                       (funcall ,ido-cannot-complete-command)))))
             ad-do-it))
   #+END_SRC

   When I open a file again, I like emacs to show me the place I
   was last time.

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     (setq-default save-place t)
     (require 'saveplace)
   #+END_SRC


   I tend to organize topics by folders and keep track of things in
   files that are all called =notes.org=. This tells emacs to use
   unique buffer names with format 'name:dir'. Copied from [[http://emacs-fu.blogspot.com/2009/11/making-buffer-names-unique.html][Emacs-fu
   blog]]. This is on by default in emacs 24.4 and uses angle brackets.

   ##+name: global-navigation
   ##+BEGIN_SRC emacs-lisp
   # ;;require 'uniquify)
   # ;;setq
   # ;;uniquify-buffer-name-style 'post-forward
   # ;;uniquify-separator ":")
   ##+END_SRC

   I just installed [[https://github.com/emacs-helm/helm][helm]] ([[https://github.com/emacs-helm/helm/wiki][wiki]]) and [[https://github.com/emacs-helm/helm-ls-git][helm-ls-git]]. 

   Something is slowing down file operations. Disabling helm!

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     ;(helm-mode 1)
     ;(global-set-key (kbd "C-x C-d") 'helm-browse-project)
   #+END_SRC



** Geographical location

  Calendar functions like to know your geographical coordinates to
  display celestial movements correctly. I am at KAUST in Saudi Arabia.

  #+name: location
  #+BEGIN_SRC emacs-lisp
    (setq calendar-latitude 22.3)
    (setq calendar-longitude 39.1)
    (setq calendar-location-name "KAUST")
  #+END_SRC

  It is possible (see package =osx-location=) to link emacs to location
  information from the operating system.

* Utilities

** News feed

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
   (setq elfeed-feeds
         '(("http://feeds.bbci.co.uk/news/world/rss.xml" news)
          ("http://feeds.bbci.co.uk/news/science_and_environment/rss.xml" news)
          ("http://feeds.bbci.co.uk/news/technology/rss.xml" news)
          ("http://feeds.bbci.co.uk/news/health/rss.xml" news)
          ("http://kimmo.suominen.com/stuff/vw.xml" comics)
          ("http://kimmo.suominen.com/stuff/fingerpori.xml" comics)
          ("http://soloalgunaspalabras.wordpress.com/feed/" friends)
          ("http://listenlearnread.blogspot.com/feeds/posts/default" friends)
          ("http://perltricks.com/feed/rss" perl)))
   (global-set-key (kbd "C-c f") 'elfeed)
   #+END_SRC

** Regex tool

   Coming from perl regexps, I find emacs regexps confusing. I have
   installed a package =regexp-tool= that can be invoked by =M-x
   regexp-tool=. It will open a new frame with three windows: Regex,
   Text and Groups. This allows me to tune my regexps. The variable
   =regex-tool-backend= defaults to =emacs=, but can be changed to
   =perl=.

   Now that [[https://github.com/emacs-helm/helm][helm]] ([[https://github.com/emacs-helm/helm/wiki][wiki]]) is installed, I am learning new tricks every
   day. Regexp can be tested on current buffer or region with =M-x
   helm-regexp=.

   =M-x qrr= runs =query-replace-regexp= that by default has a really
   complicated key binding =M-C-S %=.

   Read more on [[http://www.emacswiki.org/emacs/RegularExpression][emacs regexps]].

** ChangeLog mode

   While git and other distributed version control systems (see
   [[Version control]]) do a great job in keeping track of changes
   projects, sometimes you need something more general. Enter ancient
   [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Change-Log-Commands.html][ChangeLog]] mode that predates all other version control systems. It
   assumes that there is file is called =ChangeLog= somewhere in the
   file hierarchy above the current file and gives you a strange key
   chord =C-x 4 a= to add an entry to it.

   I use it to keep a log of OS wide changes to my computers (thanks
   for Martin Senger for teaching me the habit! ). Each computer has a
   ChangeLog file in its own directory and the whole project is under
   git control. When running install, uninstall, or configure commands
   I open the relevant file and create a record of the change and
   where the information came from.

** How Do I?

   Programming questions can be answered within emacs by
   =howdoi-query= or =howdoi-query-line-at-point=. This will google
   the answer in [[http://stackoverflow.com/][StackOverflow]], and parse and return best answers.

   #+BEGIN_SRC emacs-lisp
     ; execute this lisp code in org mode
     ; by placing the curser after
     ; the closing parenthesis and press C-x C-e
     (describe-package 'howdoi)
   #+END_SRC

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     (require 'howdoi)
   #+END_SRC

** Toys

*** xkcd comics

    The [[https://github.com/vibhavp/emacs-xkcd][xkcd]] package implements an [[Http://xkcd.com/][xkcd]] comics reader for Emacs.
    =xkcd-get= or =xkcd-get-latest= commands fetch you a strip that is
    stored locally.

    | Keybinding | Use                             | Function                        |
    |------------+---------------------------------+---------------------------------|
    | t          | Show alt-text in the minibuffer | (xkcd-alt-text)                 |
    | r          | Show random strip               | (xkcd-rand)                     |
    | q          | Kill buffer                     | (xkcd-kill-buffer)              |
    | <right>    | Load next xkcd                  | (xkcd-next)                     |
    | <left>     | Load previous xkcd              | (xkcd-prev)                     |
    | o          | Show strip in browser           | (xkcd-open-browser)             |
    | e          | Show explanation to strip       | (xkcd-open-explanation-browser) |

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-c x") 'xkcd)
   #+END_SRC

*** 2048-game

    Pure emacs and text-only version of [[http://gabrielecirulli.github.io/2048/][2048]] is called =2048-mode=.

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     (require '2048-game)
     (global-set-key (kbd "C-c 2") '2048-game)
   #+END_SRC


* Org Mode

  [[http://orgmode.org/][Org mode]] is for all plain text editing. Lets bind the Org mode
  online info to =C-c o= since it is so useful.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (global-set-key "\C-co" 'org-info)
   #+END_SRC

  Text in other modes than org can be selected ("marked") by
  =S-<arrow>=. In org mode these keys have special functions in lists
  and headers and are otherwise disabled. The alternative is to press
  =C-<space>= and arrow keys, but in Macs that key combination is used
  to pop up Spotlight search field. To enable it, I've changed
  Spotlight key =Cmnd-<space>=. It has a knock-on effect on disabling
  the toggling of the active keyboard languages, but I can live with
  that.

** Agenda

   You have to tell org-mode which files contain your agenda. Only
   these files will be searched using agenda commands. This adds all
   files from the directory. I am using DropBox to get one more way to
   backup these important files.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-agenda-files '("~/Dropbox/org"))
   #+END_SRC

   This sets the agenda calendar work week to start on Sunday
   according to Saudi Arabian custom.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-agenda-start-on-weekday 7)
   #+END_SRC

   Tags can be added to any agenda item manually or preferebly by pulling
   them from a list. At the agenda item header, hit =C-c C-q= to see the
   list and select any subset of tags by pressing the shortcut key(s).

  #+name: org-config
   #+BEGIN_SRC emacs-lisp
    (setq org-tag-alist (quote (("BITCOIN" . ?a)
                               ("BIO"     . ?b)
                               ("COMP"    . ?c)
                               ("EMACS"   . ?e)
                               ("FOOD"    . ?d)
                               ("PHOTO"   . ?f)
                               ("GIT"     . ?g)
                               ("HOME"    . ?h)
                               ("LATEX"   . ?l)
                               ("MAP"     . ?m)
                               ("ORG"     . ?o)
                               ("PERL"    . ?p)
                               ("WORK"    . ?w)
                               ("PYTHON"  . ?y)
                               ("ZSH"     . ?z)
                               )))
   #+END_SRC

   The agenda command pulls all active events and todos from files
   together.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (global-set-key "\C-ca" 'org-agenda)
     (global-set-key "\C-cc" 'org-capture)
     (global-set-key "\C-cl" 'org-store-link)
     (global-set-key "\C-cb" 'org-iswitchb)
   #+END_SRC

   In addition, use =C-c C-l= to store current position (copy);

   Org-agenda needs to be loaded before calling =org-agenda= works.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
        (require 'org-agenda)
   #+END_SRC

   I prefer a forthnight's overview on the agenda and warnings 5 days
   before deadline.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-agenda-span 14)
     (setq org-deadline-warning-days 5)
   #+END_SRC

** Capture templates

   First we have to tell emacs where we want to store all captured
   notes.  I keep all files in DropBox.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-directory "~/Dropbox/org")
     (setq org-default-notes-file "~/Dropbox/org/reference.org")
   #+END_SRC

   I copied these capture templates from [[http://doc.norang.ca/org-mode.html][this excellent page]] and
   modified to my own use. I try to minimize refiling.  I have three
   main categories of entries:
   1) *notes [n]* for all note taking (URLs, ideas, papers,...) that
      can be filed away for later retrieval. They are time stamped,
      stored in that order and have optional tags I defined in the
      previous section.
   2) *todos [t]* for notes with scheduled time (defaults to date
      only) when it needs to be completed. These are added to the
      agenda.
   3) *events [e]* regular events with no completion but date and
      time. If an event is a recurring one, it will edited and moved
      to a different section of the file.

   These are stored in their own files. Events are in
   =calendar.org= that starts with sections for anniversaries and
   other recurring tasks.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     ;; Capture templates for: TODO tasks, Notes, appointments, phone calls, and org-protocol
     (setq org-capture-templates
            (quote (
                    ("n" "note" entry (file+datetree "~/Dropbox/org/reference.org")
                     "* %?\nEntered on %U\n  %i")
                    ("t" "todo" entry (file+datetree "~/Dropbox/org/todo.org")
                     "* TODO %?\n     SCHEDULED: %t\n%i\nEntered on %U")
                    ("e" "event" entry (file+datetree "~/Dropbox/org/calendar.org")
                     "* %?\n     %T\n%i\nEntered on %U")
                   )))
   #+END_SRC

#   #+name: org-config-inactive
#   #+BEGIN_SRC emacs-lisp
#     (setq org-capture-templates
#            (quote (
#                    ;; next entries are not in active use
#                    ("j" "Journal" entry (file+datetree "~/Dropbox/org/journal.org")
#                     "* %?\nEntered on %U\n  %i\n")
#                    ("r" "respond" entry (file "~/Dropbox/org/reference.org")
#                     "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t)
#                    ("x" "notex" entry (file "~/Dropbox/org/reference.org")
#                     "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
#                    ("p" "Phone call" entry (file "~/Dropbox/org/reference.org")
#                     "* PHONE %? :PHONE:\n%U" :clock-in t :clock-resume t)
#                    ("h" "Habit" entry (file "~/Dropbox/org/calandar.org")
#                     "* NEXT %?\n%U\n%a\nSCHEDULED: %(format-time-string \"<%Y-%m-%d %a .+1d/3d>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n"))))
#   #+END_SRC


   Todos can have additional keywords with dates: =DEADLINE= =C-c C-d=
   for the time the task needs to be finished, and =SCHEDULED= =C-c
   C-s= for the date when to start working on the task.

   Additionally, there are templates for the [[Ledger]] accounting program
   for several accounts. The path to the file must exist.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-capture-templates
           (append '(("l" "Ledger entries")
                     ("lm" "MasterCard" plain
                      (file "~/Documents/ledger/refile.led")
                      "
     %(org-read-date) %^{Payee}
          ; entered: %U
          Liabilities:MasterCard
          Expenses:%^{Account}              € %^{Amount}
     " :empty-lines-before 1)
                     ("lc" "Cash" plain
                      (file "~/Documents/ledger/refile.led")
                      "
     %(org-read-date) * %^{Payee}
         ; entered: %U
         Expenses:Cash
         Expenses:%^{Account}              %^{Amount}
     " :empty-lines-before 1 )
                     ("ls" "SAR debit" plain
                      (file "~/Documents/ledger/refile.led")
                      "
     %(org-read-date) * %^{Payee}
         ; entered: %U
         Assets:Samba
         Expenses:%^{Account}              %^{Amount} SAR
     " :empty-lines-before 1 )
        ("le" "EUR debit" plain
                      (file "~/Documents/ledger/refile.led")
                      "
     %(org-read-date) * %^{Payee}
         ; entered: %U
         Assets:Heikintili
         Expenses:%^{Account}               € %^{Amount}
     " :empty-lines-before 1 ))
            org-capture-templates))
   #+END_SRC

** Refile

   Captured notes are kept in a temporary file, and periodically
   refiled into their proper places. Or so goes the threory. Since I
   create all notes directly into the correct file, there is nothing
   to refile. This block is here only as a reminder.

   Refile =(org-refile)= is bound to =C-c C-w=.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     ;; Targets include this file and any file contributing to the agenda - up to 3 levels deep
     (setq org-refile-targets (quote ((nil :maxlevel . 3)
                                      (org-agenda-files :maxlevel . 3))))

     ;; Use full outline paths for refile targets - we file directly with IDO
     (setq org-refile-use-outline-path t)

     ;; Targets complete directly with IDO
     (setq org-outline-path-complete-in-steps nil)

     ;; Allow refile to create parent tasks with confirmation
     (setq org-refile-allow-creating-parent-nodes (quote confirm))

     ;; Use IDO for both buffer and file completion and ido-everywhere to t
     (setq org-completion-use-ido t)
     (setq ido-everywhere t)
     (setq ido-max-directory-size 100000)
     (ido-mode (quote both))

     ;; Refile settings
     ;; Exclude DONE state tasks from refile targets
     ;;(defun bh/verify-refile-target ()
     ;;  "Exclude todo keywords with a done state from refile targets"
     ;;  (not (member (nth 2 (org-heading-components)) org-done-keywords)))
     ;;
     ;;(setq org-refile-target-verify-function 'bh/verify-refile-target)

   #+END_SRC

** TODO MobileOrg
   Use Dropbox for syncing my agenda files with my Android
   phone. Worry about the security implications later.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-mobile-directory "~/Dropbox/org")
   #+END_SRC
** External jars

   Tell emacs where to find external dependencies. Ditaa and PlantUML are
   java jar files. Ditaa is part of org-mode git repository but
   [[http://sourceforge.net/projects/plantuml/files/plantuml.jar/download][PlantUML]] needs to be downloaded and placed somewhere where Emacs
   can find it. PlantUML need to be called in fundamental mode
   (find out why).

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-ditaa-jar-path "~/src/org-mode/contrib/scripts/ditaa.jar")
     (setq org-plantuml-jar-path
           (expand-file-name "~/.emacs.d/bin/plantuml.jar"))
     ;; Use fundamental mode when editing plantuml blocks with C-c '
     (add-to-list 'org-src-lang-modes (quote ("plantuml" . fundamental)))
   #+END_SRC

** TODOs

   Make custom markers for todo items:

   - TODO :: something that needs to be done at some point. If it
             has a date, it should be done on that day but it may be
             moved.

   - PENDING :: something that's awaiting feedback from someone
                else. If it has a date, it needs followup if there
                hasn't been any feedback at that time.

   - MEETING :: a scheduled meeting and cannot easily be rescheduled.

   - DONE :: done.

   - CANCELED :: can be ignored. May include a note on why it's been
                 cancelled.

   Todos are applied by placing the cursor on the header or item line and
   shift arrow left or right, or accessing the list by =C-c C-t=.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-todo-keywords
           '((sequence "TODO(t)" "PENDING(p)" "MEETING(m)" "|" "DONE(d)" "CANCELED(c)")))

   #+END_SRC

   Automatically mark todo items with todo subitems as DONE when all
   subitems are done.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp

     (defun my-org-autodone (n-done n-not-done)
       "Switch entry to DONE when all subentries are done, to TODO otherwise."
       (let (org-log-done org-log-states)   ; turn off logging
         (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

     (add-hook 'org-after-todo-statistics-hook 'my-org-autodone)

   #+END_SRC

   I want to file and refile notes to any main header in any file in
   my =org-agenda-files= list.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-refile-targets '((nil :level . 3)
                                (org-agenda-files :level . 3)))

   #+END_SRC

   Add timestamp to all DONE items.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-log-done 'time)
   #+END_SRC

** Org-Babel

   Run code with a block by =C-c C-c= without confirmation. This is a
   known security risk, but makes life easier. Beware.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-confirm-babel-evaluate nil)
   #+END_SRC

   Use syntax highlighting ("fontification") in org-mode source
   blocks, and use a slightly darker background to visually separate
   the source block from its surroundings.

   This also highlights source blocks in HTML exports.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-src-fontify-natively 't)
     (set-face-attribute 'org-block-background nil
                         :background "#f0f0e8")
   #+END_SRC

   Use the =minted= package for syntax highlighting source blocks in
   LaTeX / PDF exports. It needs the python =Pygments= library.
   Install it e.g. =sudo easy_install Pygments=.  Configuration copied
   from a blog post by [[http://joat-programmer.blogspot.nl/2013/07/org-mode-version-8-and-pdf-export-with.html][Florian Bergmann]].  Check also the blog entry by
   [[ http://praveen.kumar.in/2012/03/10/org-mode-latex-and-minted-syntax-highlighting/][Praveen Kumar]].

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     ;; Include the latex-exporter
     (require 'ox-latex)
     ;; Add minted to the defaults packages to include when exporting.
     (add-to-list 'org-latex-packages-alist '("" "minted"))
     ;; Tell the latex export to use the minted package for source
     ;; code coloration.
     (setq org-latex-listings 'minted)
     ;; Let the exporter use the -shell-escape option to let latex
     ;; execute external programs.
     ;; This obviously can be dangerous!
     (setq org-latex-pdf-process
           '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

   #+END_SRC


   My additions and overrides inlude export to Beamer presentations, too.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
      (require 'ox-beamer)
   #+END_SRC

   Slower but more robust latex-to-PDF processing uses =latexmk=. It
   is inactivated here because the above xelatax call seems to work
   well.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
;     (setq org-latex-pdf-process
;       '("/usr/texbin/latexmk -interaction=nonstopmode -shell-escape -pdflatex=/usr/texbin/xelatex -gg -f -pdf %f"))
   #+END_SRC


   Untangle files.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (global-set-key "\C-ci" 'my/org-babel-untangle)

     (defun my/org-babel-untangle (path)
       (interactive "fFile to include: ")
       (message "Untangling '%s'..." path)
       (save-current-buffer
         (let ((lang (save-current-buffer
                       (set-buffer (find-file-noselect path))
                       (my/mode->language major-mode))))
           (insert (format "\n** %s\n\n#+BEGIN_SRC %s :tangle %s\n"
                           (capitalize (replace-regexp-in-string "\\[_-\\]" " " (file-name-base path)))
                           lang
                           (file-relative-name path)))
           (forward-char (cadr (insert-file-contents path)))
           (insert "\n#+" "END_SRC\n"))))

     (defun my/mode->language (mode)
       "Return the language for the given mode"
       (intern (replace-regexp-in-string "\\-mode$" "" (my/->string mode))))

     (defun my/org-babel-untangle-tree (path)
       (interactive "Droot directory to untangle: ")
       (mapc 'my/org-babel-untangle
             (cl-remove-if 'file-directory-p
                           (f-files path (lambda (p) t) t))))

   #+END_SRC

   Display images created by a source block in the same document.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-babel-after-execute-hook 'my/display-inline-images 'append)
     (defun my/display-inline-images ()
       (condition-case nil
           (org-display-inline-images)
         (error nil)))
   #+END_SRC

** Markdown export

   Org mode does not give markdown as an export option before you
   tell it to.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (require 'ox-md)
   #+END_SRC

** Latex export

   This defines a new latex class =fu-org-article= based on the
   article class that has fresher and more compact look than the
   default article. The fonts used in the output are [[http://www.linuxlibertine.org/][Linux
   Libertine]]. The Latex binaries and packages come from [[http://www.tug.org/texlive/][Tex Live]].

   The original code from [[http://emacs-fu.blogspot.com/2011/04/nice-looking-pdfs-with-org-mode-and.html][emacs-fu]] blog has been amended and modified
   several times.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'org-latex-classes
                  '("fu-org-article"
     "\\documentclass[11pt,a4paper]{article}
     \\usepackage[T1]{fontenc}
     \\usepackage{xunicode}        % for XeTex
     \\usepackage{fontspec}        % for XeTex
     \\usepackage{xltxtra}         % for XeTex
     \\usepackage{url}             % for XeTex to break long URLs at line ending
     \\usepackage[english]{babel}  % for XeTex
     \\usepackage[osf]{libertine}  % Libertine fonts with old-style numbers
     \\usepackage{graphicx}
     \\usepackage{minted}
     \\usepackage{hypernat}
     \\usepackage[round]{natbib}

     \\usepackage{paralist}
     \\let\\itemize\\compactitem
     \\let\\description\\compactdesc
     \\let\\enumerate\\compactenum

     \\usepackage[a4paper, textheight=10in,
                 marginparsep=7pt, marginparwidth=.6in]{geometry}

     \\usepackage[colorlinks=true,urlcolor=black,linkcolor=black,citecolor=blue]{hyperref}

     \\let\\nofiles\\relax % Void the \\nofiles command

     \\pagestyle{plain}
     \\title{}
           [NO-DEFAULT-PACKAGES]
           [NO-PACKAGES]"
                    ("\\section{%s}" . "\\section*{%s}")
                    ("\\subsection{%s}" . "\\subsection*{%s}")
                    ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                    ("\\paragraph{%s}" . "\\paragraph*{%s}")
                    ("\\subparagraph{%s}" . "\\subparagraph*{%s}")
                    )
                  )

   #+END_SRC

** Language evaluation support

   Org-Babel needs to be told that evaluation of certain languages is
   allowed. I collect all languages here, then enable all of them at
   the end of the section.

   #+name: org-config :noweb no-export
   #+BEGIN_SRC emacs-lisp
     (defvar my/org-babel-evaluated-languages
       '(emacs-lisp)
       "List of languages that may be evaluated in Org documents")

     <<org-config-languages>>

     (org-babel-do-load-languages
      'org-babel-load-languages
      (mapcar (lambda (lang)
                (cons lang t))
              my/org-babel-evaluated-languages))
   #+END_SRC

*** General programming languages

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'perl)
   #+END_SRC

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'clojure)
   #+END_SRC

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'ruby)
   #+END_SRC

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'sh)
   #+END_SRC

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'python)
   #+END_SRC

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'emacs-lisp)
   #+END_SRC

*** Statistics

    [[http://www.r-project.org/][R]] has been the new S for a long time.

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'R)
   #+END_SRC

*** Diagramming

   I like [[http://www.graphviz.org/][Graphviz]] for generating graphs. It takes a few lines of code
   to link graphviz's =dot= mode to =org-babel= so I can include dot
   source in org mode and export with nice looking diagrams.

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'org-src-lang-modes (quote ("dot" . graphviz-dot)))

     (add-to-list 'my/org-babel-evaluated-languages 'dot)
   #+END_SRC

   [[http://ditaa.sourceforge.net/][Ditaa]] is another nice package for turning ASCII art into PNG/EPS
   diagrams. Turn that on, too.

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'ditaa)
   #+END_SRC

   [[http://plantuml.sourceforge.net/][PlantUML]] is built on top of Graphviz.

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'plantuml)
   #+END_SRC

   The lowest thing around is [[http://www.gnuplot.info/][gnuplot]].

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'gnuplot)
   #+END_SRC

*** Databases

    SQL is relational database language.

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'sql)
   #+END_SRC

    SQLite is a common variant of SQL.

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'sqlite)
   #+END_SRC

*** Typesetting

    org itself can be evaluated.

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'org)
   #+END_SRC


    [[http://latex-project.org/][Latex]] is always needed.

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'latex)
   #+END_SRC

   Lilypond is a [[http://www.lilypond.org/][music typesetting language]].

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'lilypond)
   #+END_SRC

** Shortcuts for some language blocks

   There are some source blocks that I use more than others. To save
   time typing them, I've defined [[http://www.emacswiki.org/emacs/SkeletonMode][skeletons]] with abbreviations for them.

   *sblk* - Generic with interactive type.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (define-skeleton skel-org-block
       "Insert an org block, querying for type."
       "Type: "
       "#+BEGIN_SRC " str "\n"
       _ -
       "\n#+END_SRC\n")
     (define-abbrev org-mode-abbrev-table "sblk" "" 'skel-org-block-source)
   #+END_SRC

   *pblk* - perl block with shebang

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (define-skeleton skel-org-block-perl
       "Insert an org perl block with results in the output."
       ""
       "#+HEADERS: :results output :exports both :shebang \"#!/usr/bin/env perl\"\n#+BEGIN_SRC perl :tangle yes\n"
       _ -
       "\n#+END_SRC\n")

     (define-abbrev org-mode-abbrev-table "pblk" "" 'skel-org-block-perl)
   #+END_SRC

   *rblk* -- R block  optimised for inline graphics

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (define-skeleton skel-org-block-r
       "Insert an org R block with results in the output."
       ""
       "#+HEADER: :session *R* :cache yes :results output graphics :exports both :tangle yes\n#+BEGIN_SRC R  :file a.png  :width 500 :height 500\n"
       _ -
       "\n#+END_SRC\n")

     (define-abbrev org-mode-abbrev-table "rblk" "" 'skel-org-block-r)
   #+END_SRC

   *splant* - PlantUML Source block

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (define-skeleton skel-org-block-plantuml
       "Insert a org plantuml block, querying for filename."
       "File (no extension): "
       "#+BEGIN_SRC plantuml :file " str ".png\n"
       _ -
       "\n#+END_SRC\n")

     (define-abbrev org-mode-abbrev-table "splant" "" 'skel-org-block-plantuml)
   #+END_SRC

   *sdot* - Graphviz DOT block

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (define-skeleton skel-org-block-dot
       "Insert a org graphviz dot block, querying for filename."
       "File (no extension): "
       "#+BEGIN_SRC dot :file " str ".png :cmdline -Kdot -Tpng\n"
       "graph G {\n"
       _ - \n
       "}"
       "\n#+END_SRC\n")

     (define-abbrev org-mode-abbrev-table "sdot" "" 'skel-org-block-dot)
   #+END_SRC


  *sditaa* - Ditaa source block

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (define-skeleton skel-org-block-ditaa
       "Insert a org ditaa block, querying for filename."
       "File (no extension): "
       "#+BEGIN_SRC ditaa :file " str ".png  :cmdline -r\n"
       _ -
       "\n#+END_SRC\n")

     (define-abbrev org-mode-abbrev-table "sditaa" "" 'skel-org-block-ditaa)
   #+END_SRC

   *lblk* - Emacs Lisp source block

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (define-skeleton skel-org-block-elisp
       "Insert a org emacs-lisp block"
       ""
       "#+BEGIN_SRC emacs-lisp\n"
       _ -
       "\n#+END_SRC\n")

     (define-abbrev org-mode-abbrev-table "lblk" "" 'skel-org-block-elisp)
   #+END_SRC

** References

   I have one master bib file for references.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq reftex-default-bibliography
           (quote
            ("/Users/lehvasho/Documents/latex/all.bib")))
   #+END_SRC

   The RefTex package that manages citations needs configuration. =C-c
   (= search for citation in the bibliograhy file. =C-c )= does
   something else...

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (defun org-mode-reftex-setup ()
       (load-library "reftex")
       (and (buffer-file-name) (file-exists-p (buffer-file-name))
            (progn
              ;enable auto-revert-mode to update reftex when bibtex file changes
              (global-auto-revert-mode t)
            (reftex-parse-all))
       (define-key org-mode-map (kbd "C-c )") 'reftex-citation)
       (define-key org-mode-map (kbd "C-c (") 'org-mode-reftex-search))
       )
     (add-hook 'org-mode-hook 'org-mode-reftex-setup)
   #+END_SRC

   Bibliography is needed only in some documents. I have defined an
   abbreviation *obiblio* that adds these two lines to the
   document. Place them to the end. Read more about [[http://merkel.zoneo.net/Latex/natbib.php][natbib]].

   #+BEGIN_EXAMPLE
     \bibliographystyle{natbib}{}
     \bibliography{bibfilename}
   #+END_EXAMPLE

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (define-skeleton skel-org-block-bibl
       "Insert a org/lisp bibliography block"
       ""
       "\n\\bibliographystyle{plainnat}\n\\bibliography{/Users/lehvasho/Documents/latex/all.bib}\n"
       _ -
       "")

     (define-abbrev org-mode-abbrev-table "obiblio" "" 'skel-org-block-bibl)
   #+END_SRC

** Presentation

   The org mode can be used to export presentations in fancy HTML5
   Reveal.js  format. Read more at [[https://github.com/yjwen/org-reveal/blob/master/Readme.org][GitHub]].

   To start using it, first clone the org-reveal repository, then
   create a copy of the =Readme.org= file and edit it with emacs.

   #+BEGIN_SRC sh
     cd ~/src/
     git clone https://github.com/yjwen/org-reveal.git
   #+END_SRC

   Then activate the org-reveal mode and tell its location to emacs.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-reveal-root "/Users/lehvasho/src/reveal.js")
     (if (file-exists-p org-reveal-root)
         (require 'ox-reveal)
       (message "ERROR: Can not find reveal.js directory"))
   #+END_SRC

** Master file fix

   org-mode asks for a (LaTeX) master file when opening the first org file in
   emacs.  Discussion and [[http://lists.gnu.org/archive/html/emacs-orgmode/2012-02/msg00759.html][fix]] was provided.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq TeX-auto-save t)
     (setq TeX-parse-self t)
     (setq-default TeX-master nil)
     (make-variable-buffer-local 'TeX-master) ;; I think this is needed because the variable is not buffer local until Auctex is active

     (defun org-mode-reftex-setup ()
       (setq TeX-master t)
       (load-library "reftex")
       (and (buffer-file-name)
            (file-exists-p (buffer-file-name))
            (progn
          (reftex-parse-all)
          (reftex-set-cite-format "[[cite:%l][%l]]")))
       (define-key org-mode-map (kbd "C-c )") 'reftex-citation)
       (define-key org-mode-map (kbd "C-c (") 'org-mode-reftex-search))
     (add-hook 'org-mode-hook 'org-mode-reftex-setup)

   #+END_SRC

* Configuration file layout

  Here I define the emacs.el file that gets generated by the code in
  this org file.

  #+BEGIN_SRC emacs-lisp :tangle yes :noweb no-export :exports code
    ;;;; Do not modify this file by hand.  It was automatically generated
    ;;;; from `emacs.org` in the same directory. See that file for more
    ;;;; information.
    ;;;;
    ;;;; If you cannot find the `emacs.org` file, see the source
    ;;;; repository at https://github.com/heikkil/emacs-literal-config

    <<environment>>
    <<tools>>
    <<customize-config>>
    <<look-and-feel>>
    <<formatting>>
    <<abbreviations>>
    <<version-control>>
    <<spell-checker>>
    <<text-files>>
    <<programming-setup>>
    <<auto-complete>>
    <<local-navigation>>
    <<global-navigation>>
    <<location>>
    <<org-config>>
    <<startup>>
    <<execute-last>>
  #+END_SRC
* Tools

  This section defines some functionality used elsewhere in this
  configuration.

** Hooks and modes

   #+name: tools
   #+BEGIN_SRC emacs-lisp
     (defun my/->string (str)
       (cond
        ((stringp str) str)
        ((symbolp str) (symbol-name str))))

     (defun my/->mode-hook (name)
       "Turn mode name into hook symbol"
       (intern (replace-regexp-in-string "\\(-mode\\)?\\(-hook\\)?$"
                                         "-mode-hook"
                                         (my/->string name))))

     (defun my/->mode (name)
       "Turn mode name into mode symbol"
       (intern (replace-regexp-in-string "\\(-mode\\)?$"
                                         "-mode"
                                         (my/->string name))))

     (defun my/turn-on (&rest mode-list)
       "Turn on the given (minor) modes."
       (dolist (m mode-list)
         (funcall (my/->mode m) +1)))

     (defvar my/normal-base-modes
       (mapcar 'my/->mode '(text prog))
       "The list of modes that are considered base modes for
       programming and text editing. In an ideal world, this should
       just be text-mode and prog-mode, however, some modes that
       should derive from prog-mode derive from fundamental-mode
       instead. They are added here.")

     (defun my/normal-mode-hooks ()
       "Returns the mode-hooks for `my/normal-base-modes`"
       (mapcar 'my/->mode-hook my/normal-base-modes))

   #+END_SRC

* Environment

** OS X

   OS X doesn't set the environment from the shell init files for
   graphical applications, but I set PATH and a bunch of other stuff
   there. The =exec-path-from-shell= package will take care of
   that. Thanks to Ting-Yu Lin for pointing it out.

   Although I have been using the fish shell for while, I was only
   recently bitten by a problem of loosing PATH. The fix was found
   [[https://github.com/purcell/exec-path-from-shell/issues/9][here]].

   #+NAME: environment
   #+BEGIN_SRC emacs-lisp
       ;;(when (eq system-type 'darwin)
       ;;  (exec-path-from-shell-initialize)
       ;;  (when (equal (file-name-nondirectory (getenv "SHELL")) "fish")
       ;;    (setq exec-path (split-string (car exec-path) " "))))
     (when (file-name-nondirectory (getenv "SHELL")) "fish"
           (setq path-separator " ")
           (exec-path-from-shell-initialize)
           (setq path-separator ":"))
   #+END_SRC

   The =locate= command is not available in OS X so alias it to mdfind.

   #+NAME: environment
   #+BEGIN_SRC emacs-lisp
    (when (eq system-type 'darwin)
      (setq locate-command "mdfind"))
   #+END_SRC

   Printing under OS X does not work in default emacs.  [[http://www.emacswiki.org/emacs/MacPrintMode][EmacsWiki]] has
   slightly outdated instructions:

   1. Copy [[ https://raw.github.com/marcora/emacs/master/mac-print-mode.el][mac-print-mode.el]] into =~.emacs.d/elisp= directory
   2. htmlize pakage should be already installed
   3. Install latest version of [[http://hmdt.jp/coral/][Coral]] (1.3)
      - Download and open the image file
      - =cp -r /Volumes/Coral1.3/bin/coral.app /Applications/=
      - =cp /Volumes/Coral1.3/bin/bin/coral /usr/local/bin/=
        and edit it so that it calls /Applications/coral.app/Contents/MacOS/coral
   4. Run the following code:

   #+NAME: environment
   #+BEGIN_SRC emacs-lisp
     (when (eq system-type 'darwin)
       (when (require 'mac-print-mode nil t)
         (mac-print-mode 1)
         (global-set-key (kbd "s-p") 'mac-print-buffer)))
   #+END_SRC

   Command-p now exports the current page as HTML and prints using the
   system dialog.

** Custom lisp package directory

   There are still lisp packages that you have to copy manually. This
   defines =$HOME/.emacs.d/elisp= directory for a place for them.

   #+NAME: environment
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path "~/.emacs.d/elisp")
   #+END_SRC

** Emacsclient

   Especially in OS X commandline and graphical UI are separated from
   each other and opening a file in a GUI program is not automatic. In
   the case of emacs, the way around this is *emacsclient* (see =man
   emacsclient=). The running emacs need to run in server mode for the
   emacsclient to open a new frame to edit the file. When you finish
   editing, close the frame by =C-x #= to continue on the command
   line.

   #+NAME: environment
   #+BEGIN_SRC emacs-lisp
     (server-start)
   #+END_SRC

   A commandline alias *em* (=alias em=emacsclient=) then calls
   emacsclient instead of emacs on the terminal. This will open a new
   emacs window with the text to edit. To finish editing, save and
   press =C-x #=. This works beautifully with fish shell command
   =funced=.

   Additionally, for those quick and dirty editing jobs on terminal, I
   have installed *zile*, [[http://www.gnu.org/software/zile/][a lightweight emacs clone]] with homebrew, and
   aliased it to *e*.

* Monkey Patches

** TODO Org-Indent-Region fix

   I (Joost) need to submit this as a patch.

   #+NAME: monkey-patches
   #+BEGIN_SRC emacs-lisp
    (eval-after-load 'org
      '(defun org-indent-region (start end)
         "Indent region."
         (interactive "r")
         (save-excursion
           (let ((line-end (org-current-line end)))
             (goto-char start)
             (while (< (org-current-line) line-end)
               (cond ((org-in-src-block-p t) (org-src-native-tab-command-maybe))
                     (t (call-interactively 'org-indent-line)))
               (move-beginning-of-line 2))))))

   #+END_SRC
